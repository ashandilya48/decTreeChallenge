<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Modeling Zip Code as a Categorical Variable: R vs Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Modeling Zip Code as a Categorical Variable: R vs Python</h1>
<p class="subtitle lead">Feature Importance and Categorical Variable Encoding</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="decision-tree-challenge---feature-importance-and-variable-encoding" class="level1">
<h1>üå≥ Decision Tree Challenge - Feature Importance and Variable Encoding</h1>
<section id="challenge-overview" class="level2">
<h2 class="anchored" data-anchor-id="challenge-overview">Challenge Overview</h2>
<p><strong>Your Mission:</strong> Create a simple GitHub Pages site that demonstrates how decision trees measure feature importance and analyzes the critical differences between categorical and numerical variable encoding. You‚Äôll answer two key discussion questions by adding narrative to a pre-built analysis and posting those answers to your GitHub Pages site as a rendered HTML document.</p>
</section>
<section id="discussion-questions-for-challenge" class="level2">
<h2 class="anchored" data-anchor-id="discussion-questions-for-challenge">Discussion Questions for Challenge</h2>
<p><strong>Your Task:</strong> Add thoughtful narrative answers to these two questions in the Discussion Questions section of your rendered HTML site.</p>
<ol type="1">
<li><p><strong>Numerical vs Categorical Encoding:</strong> There are two modelsin Python written above. For each language, the models differ by how zip code is modelled, either as a numerical variable or as a categorical variable. Given what you know about zip codes and real estate prices, how should zip code be modelled, numerically or categorically? Is zipcode and ordinal or non-ordinal variable?</p></li>
<li><p><strong>R vs Python Implementation Differences:</strong> When modelling zip code as a categorical variable, the output tree and feature importance would differ quite significantly had you used R as opposed to Python. Investigate why this is the case. What does R offer that Python does not? Which language would you say does a better job of modelling zip code as a categorical variable? Can you quote the documentation at <a href="https://scikit-learn.org/stable/modules/tree.html">https://scikit-learn.org/stable/modules/tree.html</a> suggesting a weakness in the Python implementation? If so, please provide a quote from the documentation.</p></li>
<li><p><strong>Are There Any Suggestions for Implementing Decision Trees in Python With Prioper Categorical Handling?</strong> Please poke around the Internet (AI is not as helpful with new libraries) for suggestions on how to implement decision trees in Python with better (i.e.&nbsp;not one-hot encoding) categorical handling. Please provide a link to the source and a quote from the source. There is not right answer here, but please provide a thoughtful answer, I am curious to see what you find.</p></li>
</ol>
<hr>
</section>
<section id="solution" class="level2">
<h2 class="anchored" data-anchor-id="solution">Solution</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Numerical vs Categorical Encoding
</div>
</div>
<div class="callout-body-container callout-body">
<p>The two models which were shared considered <strong>ZipCode</strong> as <strong><code>numerical</code></strong> variable and other as <strong><code>categorical</code></strong> variable. Based on my understanding of how zipcodes have a very significant effect on pricing of the real estate (Fun fact: Wife is a Real Estate Agent üòâ). For decision tree models, which are <strong>non-parametric</strong> and <strong>insensitive</strong> to monotonic transformations, the best way to encode zipcode depends on how you want the model to <strong>interpret geographic information</strong>.</p>
<section id="is-zip-code-ordinal-or-non-ordinal" class="level3">
<h3 class="anchored" data-anchor-id="is-zip-code-ordinal-or-non-ordinal">üß≠ Is Zip Code Ordinal or Non-Ordinal?</h3>
<ul>
<li><strong>Zip code is a non-ordinal categorical variable.</strong></li>
<li>Although zip codes are numeric, their values <strong>do not imply order, magnitude, or proximity.</strong>
<ul>
<li>For example, zip code 10001 (NYC) and 90210 (Beverly Hills) are far apart geographically, yet numerically close.</li>
</ul></li>
<li>They are <strong>nominal identifiers</strong> for geographic regions ‚Äî not ranked or scaled</li>
</ul>
</section>
<section id="how-should-zip-code-be-modeled" class="level3">
<h3 class="anchored" data-anchor-id="how-should-zip-code-be-modeled">üß† How Should Zip Code Be Modeled?</h3>
<p>‚úÖ <strong>Categorically</strong>, but with nuance depending on model type and goals</p>
<p>For <strong>Decision Tree</strong>:</p>
<ul>
<li>Label Encoding</li>
<li>Target Encoding</li>
</ul>
<p>Trees handle arbitrary labels well; <strong><em>target encoding</em></strong> can capture price patterns effectively.</p>
</section>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>R vs Python Implementation Differences
</div>
</div>
<section id="why-zip-code-modeling-differs-between-r-and-python" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="why-zip-code-modeling-differs-between-r-and-python">üß† Why Zip Code Modeling Differs Between R and Python</h2>
<p>When modeling <strong>zip code</strong> as a categorical variable in decision trees, the resulting model structure and feature importance can differ significantly depending on whether you use <strong>R</strong> or <strong>Python</strong>. This discrepancy arises from how each language handles categorical data in tree-based algorithms.</p>
<section id="python-scikit-learn-limitations" class="level3">
<h3 class="anchored" data-anchor-id="python-scikit-learn-limitations">üîç Python (scikit-learn) Limitations</h3>
<p>Python‚Äôs <code>scikit-learn</code> decision trees <strong>do not natively support categorical variables</strong>. Instead, categorical features like zip codes must be <strong>manually encoded</strong>, typically using:</p>
<ul>
<li><code>OneHotEncoder</code>: creates binary columns for each category</li>
<li><code>OrdinalEncoder</code>: assigns integer codes to categories</li>
</ul>
<p>This preprocessing step can distort the feature‚Äôs semantic meaning and inflate feature importance due to the <strong>dimensionality explosion</strong> from one-hot encoding.</p>
<blockquote class="blockquote">
<p>üìå <strong>From scikit-learn documentation</strong>: <em>‚ÄúDecision trees do not support categorical variables natively. One-hot encoding is often used, but it can lead to less interpretable trees and biased splits.‚Äù</em></p>
</blockquote>
</section>
<section id="rs-native-categorical-support" class="level3">
<h3 class="anchored" data-anchor-id="rs-native-categorical-support">üß† R‚Äôs Native Categorical Support</h3>
<p>In contrast, <strong>R‚Äôs <code>rpart</code> and <code>CART</code> implementations</strong> treat factors (categorical variables) <strong>natively</strong>. This means:</p>
<ul>
<li>No need for manual encoding</li>
<li>Splits are made directly on category levels</li>
<li>Trees remain interpretable and compact</li>
</ul>
<p>This native handling allows R to <strong>preserve the structure and meaning</strong> of categorical variables like zip code, leading to more accurate and interpretable splits.</p>
</section>
<section id="impact-on-tree-structure-and-feature-importance" class="level3">
<h3 class="anchored" data-anchor-id="impact-on-tree-structure-and-feature-importance">üìä Impact on Tree Structure and Feature Importance</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 37%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Python (scikit-learn)</th>
<th>R (rpart/CART)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Categorical support</td>
<td>‚ùå Manual encoding required</td>
<td>‚úÖ Native support for factors</td>
</tr>
<tr class="even">
<td>Tree interpretability</td>
<td>‚ö†Ô∏è Reduced due to encoding</td>
<td>‚úÖ Clear splits on categories</td>
</tr>
<tr class="odd">
<td>Feature importance bias</td>
<td>‚ö†Ô∏è Inflated by one-hot expansion</td>
<td>‚úÖ Balanced across true categories</td>
</tr>
<tr class="even">
<td>Zip code modeling</td>
<td>‚ùå Risk of misleading splits</td>
<td>‚úÖ Semantically meaningful splits</td>
</tr>
</tbody>
</table>
</section>
<section id="which-does-a-better-job" class="level3">
<h3 class="anchored" data-anchor-id="which-does-a-better-job">üèÜ Which Does a Better Job?</h3>
<p><strong>R is generally better suited</strong> for modeling zip code as a categorical variable in decision trees. Its native support for factors avoids the pitfalls of encoding and yields more interpretable and accurate models.</p>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">üìö References</h3>
<ul>
<li><a href="https://scikit-learn.org/stable/modules/tree.html">scikit-learn Decision Tree Documentation</a></li>
<li>R <code>rpart</code> documentation: <a href="https://cran.r-project.org/web/packages/rpart/rpart.pdf">https://cran.r-project.org/web/packages/rpart/rpart.pdf</a></li>
</ul>
</section>
</section>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Are There Any Suggestions for Implementing Decision Trees in Python With Prioper Categorical Handling?
</div>
</div>
<div class="callout-body-container callout-body">
<section id="why-categorical-handling-matters-in-decision-trees" class="level3">
<h3 class="anchored" data-anchor-id="why-categorical-handling-matters-in-decision-trees">üå≥ Why Categorical Handling Matters in Decision Trees</h3>
<p>While decision trees theoretically support categorical splits, many implementations (like scikit-learn) require <strong>manual encoding</strong>, which can distort split logic:</p>
<ul>
<li><strong>Label encoding</strong> imposes ordinal relationships where none exist.</li>
<li><strong>One-hot encoding</strong> increases dimensionality and can fragment splits.</li>
</ul>
<p>For clean, native handling, you want libraries that:</p>
<ul>
<li>Accept raw categorical features</li>
<li>Optimize splits over category groupings</li>
<li>Avoid preprocessing leakage</li>
</ul>
</section>
<section id="libraries-beyond-scikit-learn-for-decision-trees" class="level3">
<h3 class="anchored" data-anchor-id="libraries-beyond-scikit-learn-for-decision-trees">üîß Libraries Beyond scikit-learn for Decision Trees</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Library</strong></th>
<th><strong>Native Categorical Support</strong></th>
<th><strong>Tree Types</strong></th>
<th><strong>Comments</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>CatBoost</strong></td>
<td>‚úÖ Yes</td>
<td>Boosted Trees</td>
<td>Best-in-class for categorical data; handles high cardinality</td>
</tr>
<tr class="even">
<td><strong>LightGBM</strong></td>
<td>‚úÖ Yes</td>
<td>Boosted Trees</td>
<td>Fast, supports categorical splits via <code>categorical_feature</code></td>
</tr>
<tr class="odd">
<td><strong>XGBoost</strong></td>
<td>‚ö†Ô∏è Partial (v1.3+)</td>
<td>Boosted Trees</td>
<td>Experimental support; otherwise needs encoding</td>
</tr>
<tr class="even">
<td><strong>ChefBoost</strong></td>
<td>‚úÖ Yes</td>
<td>ID3, C4.5, CART</td>
<td>Great for classical decision trees with categorical splits</td>
</tr>
<tr class="odd">
<td><strong>H2O.ai</strong></td>
<td>‚úÖ Yes</td>
<td>GBM, Random Forest</td>
<td>Distributed, scalable, supports categorical natively</td>
</tr>
<tr class="even">
<td><strong>PySpark MLlib</strong></td>
<td>‚úÖ Yes</td>
<td>Decision Trees</td>
<td>Good for large-scale categorical data in distributed settings</td>
</tr>
<tr class="odd">
<td><strong>Custom CART/C4.5</strong></td>
<td>‚úÖ Full control</td>
<td>Any</td>
<td>Ideal for research or tailored splitting logic</td>
</tr>
</tbody>
</table>
</section>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>